# 문자의 표현

**컴퓨터에서의 문자 표현** : 메모리는 숫자만 저장할 수 있기 때문에 각 문자에 대해서 대응되는 숫자를 정해놓고 메모리에 저장하는 방법을 사용

네트워크가 발전되기 전 미국의 각 지역 별로 코드체계를 정해 놓고 사용

→ 네트워크가 발전하면서 서로간 정보를 주고 받을 때 정보를 달리 해석한다는 문제가 생김

⇒ ASCII라는 문자 인코딩 표준이 제정

우리나라 = 한글 코드 체계를 만들어 사용했고 조합형, 완성형 두 종류를 가지고 있음

인터넷이 전 세계로 발전하면서 자국의 코드체계를 타 국가가 가지고 있지 않으면 정보를 잘못 해석

→ 다국어 처리를 위해 표준 마련 : 유니코드

**유니코드**

USC-2, USC-4 : 유니코드를 저장하는 변수의 크기를 정의

바이트 순서를 표준화 하지 못함

→ 파일을 인식 시 어떤건지 인식하고 각 경우를 구분해서 모두 다르게 구현해야함

→ 적당한 외부 인코딩이 필요

**big-endian, little-endian - 저장방법**

저장하는 순서와 관련

유니코드 인코딩(UTF : Unicode Transformation Format)

- UTF8 (in web) : MIN 8bit, MAX 32-bit(1 Byte*4)
- UTF-16(in windows, in JAVA) : MIN 16 bit, MAX 32-bit(2 Byte * 2)
- UTF-32(in Unix) : MIN 32-bit Max 32-bit(4 Byte * 1)

---

# 문자열

### 파이썬에서의 문자열 처리

- char 타입 없음
- 텍스트 데이터의 취급방법이 통일되어있음
- 문자열 기호 ‘’, “”, “””,’’’
- + 연결(Concatenation) : 문자열 + 문자열 : 이어 붙여주는 역할
- * 반복 : 문자열 *수 : 수만큼 문자열이 반복
- 인덱싱, 슬라이싱 연산들을 사용할 수 있음
- 튜플과 같이 요소값을 변경할 수 없음
- 파이썬은 유니코드로 저장

---

# 연산

## 문자열비교

c strcmp() 함수 제공

문자열 s1이 s2보다 사전순서가 앞서면 -1 리턴

s1이 s2보다 사전 순서상 나중이면 1 리턴

```python
def my_strcump(s1, s2):
		if s1 < s2:
				return -1
		elif s1 > s2:
				return 1
		else:
				return 0
```

파이썬에서는 숫자와 문자변환 함수를 제공

int(’123’), float(’3.14’), str(123), repr(123), int(’A’, 16)(16진수라고 생각하고 바꿔라)

int()와 같은 atoi()함수 만들기

s= 123

a = atoi(s)

print(a+1)

```python
def atoi(s):
	i = 0
	for x in s:
			i = i*10 + ord(x) - ord('0')
	return i
```

---

ord : 하나의 문자를 인자로 받고 해당 문자에 해당하는 유니코드 문자로 반환

chr : 하나의 정수를 인자로 받고 해당 정수에 해당하는 유니코드 문자를 반환

---

# 패턴 매칭

## 고지식한 알고리즘(Brute Force)

본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식

```python
i=j=0
while i<N and j<M:
		if t[i] != t[j]
				i =
		else :
				 if t[i] == t[j]:
					 i += 1
					 j += 1
	if j == m:
			return i - M  # 시작위치
	else:
			return -1   # 못찾으면 -1
```

- 최악의 경우 시간 복잡도느 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O이 됨
- 길이가 10000인 문자열에서 길이가 80인패턴을 찾을 때 800000번의 비교가 일어나

## KMP 알고리즘

불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화

- next[M] : 불일치가 발생했을 경우 이동할 다음 위치’

매칭이 실패했을 때 돌아갈 곳을 계산한다

패턴을 찾은 경우 다음 비교 위치

패턴의 각 위치에 대해 매칭에 실패했을 때 돌아갈 곳을 준비해둔다

                                                                                                                                                                                                                                

## 보이어 무어 알고리즘

오른쪽에서 왼쪽으로 비교

대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘

보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼 된다

## 문자열 매칭 알고리즘 비교

찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n

고지식한 패턴 검색 알고리즘 : 수행시간 O(mn)

카프-라빈 알고리즘 : 수행 시간 -n

KMP 알고리즘 : 수행시간 -n

### 보이어-무어 알고리즘

- 두 매칭 알고리즘들의 공통점 텍스트 문자열의 문자를 적어도 한 번씩 훑는다는 것
- 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다
- 발상의 전환 : 패턴의 오른쪽부터 비교
- 최악의 경우 수행시간 -mn
- 입력에 따라 다르지만 일반적으로 시간이 덜 든다

---

# 문자열 암호화/문자열 압축

시저 암호(Caesar cipher)

평문에서 사용되고 있는 알파벳을 일정한 문자수만큼(평행이동) 시킴으로써 암호화를 행한다