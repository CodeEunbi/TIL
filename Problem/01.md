20551. 증가하는 사탕 수열
사탕을 담은 상자
- a, b, c개
- 순 증가하길 원함
- 각 상자에는 1개 이상의 사탕이 있어야함

목표
- 순증가할 수 있도록 만들자
  - 0개 이상을 먹자

내 설계
- 2번째 상자는 세번째 상자보다 작게
- 1번째 상자는 2번째 상자보다 작게
-----
자료 구조
 - 3개의 숫자 + 먹은 개수만 저장
 - 리스트 vs a, b, c로 저장

알고리즘
불가능한 케이스
- b가 2보다 작은 경우
- c가 3보다 작은 경우
 - b는 c보다 작아야 함
   - b를 c보다 작을 때까지 하나씩 감소
     - [검증]하나씩 감소하면 시간 초과 가능성, 3000까지는 가능하지 않을까?
   - b가 c보다 크다면, b = c - 1로 만들어준다
------------------------------------------------------
10580. 전봇대
전선 N개
- 교차점 발생
- 몇 개가 발생하는지 count

교차점은 무슨 조건일 때 발생할까?
- 새로운 선 시작점이 기존선보다 높고 도작점은 더 낮은 경우
- 새로운 선이 기존선의 시작점보다 낮으며 도착점이 더 높은 경우
-----------------------------------------------------
1953.
지도 - 이차원배열 입력

맨홀 뚜껑으로부터 출발
- 터널들을 이동
-> 이동할 수 있는 개수 구하기
-이동방향 : 상하좌우 -> 델타
-> 이동하지 못하는 경우
 - 현재 내 위치에서 뚫려있는 곳으로만 가능
 - 다음 위치의 입구가 뚫려있는 곳으로만 가능
---
이차원 리스트 형태+미로 탐색
끝까지 가보자(DFS)
 - 재귀 호출이 최악의 경우 2500번 발생 가능
  - 파이썬의 재귀 호출 기본 제한은 1000번
주변으로 퍼져 나가면서 확인(BFS)
 - BFS로 푸는게 쉽겠구나
---
BFS 시간 복잡도
- Queue를 활용해서 먼저 방문한 노드부터 탐색을 시작
  - 먼저 방문한 노드에서 갈 수 있는 노드들을 후보군에 추가

- O(V+E)
 - V: 정점의 개수/ E:간선의 개수
  - 정점의 개수 :2500개
     - queue에 최대 2500개까지 들어갈 수 있다 -> 여유롭구나
  - 간선의 개수 : 2500 * 4 = 10,000개
-----------------------------------------
5656.벽돌깨기
