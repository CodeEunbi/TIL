# 그래프2(25.03.20)

<aside>
🚨

**신장트리 개념 익히고 가기**

- 양방향으로 연결된 그래프 중에서
    - 모든 정점을 연결
    - 사이클이 없는 트리(n이 3 이상일 때 사이클이 없는 트리)
    
    → 하나의 그래프에서 여러 개가 나올 수 있다
    
- 최소 비용 신장 트리(MST)
    - 가중치의 합이 가장 작은 신장 트리
</aside>

## 최소 비용 신장 트리(MST)

- 그래프에서 최소 비용 문제
    - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리 → MST
    - 두 정점 사이의 최소 비용 경로 찾기 → 최단 거리 문제
- 신장 트리
    - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(Minimum Spanning Tree)
    - 무방향(양방향) 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

인접 행렬 - 0이면 연결 안됨, 연결 + 가중치

인접 리스트 - 2가지 정보를 저장(1,  32)→1부터 32를 갑니다?



---

<aside>
🔎

**MST 구현 방법**

- Prim 알고리즘 : 특정 정점을 기준으로 작은 걸 고름
- Kruskal 알고리즘 : 간선들을 기준으로 작은 걸 고름
</aside>

# Prim 알고리즘

하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식

1. 임의 정점을 하나 선택해서 시작
2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선(가중치가 가장 작은 것)이 존재하는 정점을 선택
3. 모든 정점이 선택될 때까지 1), 2) 과정을 반복

서로소인 2개의 집합(2 disjoint-sets)정보를 유지

- 트리의 정점들(tree vertices) : MST를 만들기 위해 선택된 정점들
- 비트리 정점들(nontree vertices) : 선택되지 않은 정점들


priority queue(heap 트리) : 우선순위 큐


---

# Kruskal 알고리즘

간선을 기준으로!

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
    - 최초 모든 간선을 가중치에 따라 오름차순으로 정렬
    - 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
        - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
            
            ⇒ (union-find 같은 집합끼리 연결하면 사이클이 발생)
            
        - n - 1개의 간선이 선택될 때까지 바로 위를 반복
    



최소 신장 트리 ⇒? 최소 값(가중치의 합)은 항상 동일

단 , 연결한 노드는 다를 수 있다


<aside>
🆚

**가중치의 합이 가장 작은 신장 트리 차이점**

**프림 vs 크루스칼**

- 공통점 : MST를 구하기 위한 알고리즘

**📊프림(정점을 기준으로 MST를 구성하자)**

- 시간 복잡도: 0((V+E) logV)]  → logV⇒ heapq
- 정점이 많을 수록
- 보통 정점보다 간선이 더 많다
    - O(E log V)
- 간선의 수가 적을수록 유리
- 간선을 모두 고려하면서 우선순위 큐에 넣어야함

**📊크루사칼(간선을 기준으로 MST를 구성하자)**

- 시간 복잡도 : O(E log E)
- 간선 위주로 정렬
    - 간선이 많으면 많을 수록 유리하다

**📊다익스트라**

- 시간복잡도 : O( ( V + E) log V)
- 음수 + 양수가 섞여 있는 문제는 못푼다!
- 양수만 있는 그래프에서 최대 거리는 풀 수 있다
    - 가중치를 모두 음수로 만들면 된다

→ 벨만포드, 플로이드 워셜

- 다익스트라로 해결 못하는 문제들을 풀기 위해
- 성능은 안좋음ㅋㅋ, 시간 복잡도가 안좋음
- 구현이 쉽다
</aside>

---

# 최단 경로(Dijkstra)

## 최단 경로

간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

- 하나의 시작 정점에서 끝 정점까지의 최단 경로
    - 다익스트라(dijkstra)알고리즘
        - 음의 가중치를 허용하지 않음(음수 + 양수가 섞여 있는 문제)
    - 벨만-포드(Bellman-Ford)알고리즘
        - 음의 가중치 허용
- 모든 정점들에 대한 최댄 경로
    - 플로이드-워샬(Floyd-Warshall) 알고리즘

## Dijkstra 알고리즘

- 시작 정점에서 거리가 최소(누적 거리)인 정점을 선택해 나가면서 최단 경로를 구하는 방식
- 시작 정점(s)에서 끝정점(t)까지의 최단 경로에 정점x가 존재
- 이 때 최단 경로는 s에서 x까지의 최단 경로와  x에서 t까지의 최단 경로 구성된다
- 탐욕 기법을 사용한 알고리즘으로  MST의 프림 알고리즘과 유사



화살표 방향 확인!!!

- 초기화 = 무한대

- 그림 그려보기(누적거리, 방문한 순서, 우선순위 큐)

### 알고리즘


- 음수 + 양수는 왜 안될까?
    - 그리디로 접근할 수 없음  → 다른 알고리즘으로 넘어가야 함

<aside>
🔎

**최종 정리**

**📊MST(최소 신장 트리)**

- 양방향 그래프에서 최소한의 간선으로 모든 노드를 연결하는 트리

       (노드의 수 N개일 때 N -1의 간선)

**📊Prim**

- 정점을 기준으로 작은 가중치부터 고르자
    - 우선순위 큐가 사용
    - 시간 복잡도 :  (VlogV + ElogV)
        - VlogV : 보통 E가 더 크기 때문에 생략
        - ElogE : E개의 간선을 우선순위 큐에 넣는 시간
        
             → 트리의 높이가 최적화를 하지 않아도 logE만큼 높아지지 않는다 
        
             → 그만큼 시간이 빨라진다
        
        - 결론 : 간선이 많을 수록 유리하다
    - 노드의 수 : 1000개
    
          → 완전 그래프
    
          → 모든 간선의 수 : 약 50만개  ⇒ 50만개가 힙에 삽입됨
    
          → 최적화하면 빠름
    

    

❓정점에 비해 간선의 수가 얼마나 많으면 prim이 유리할까?

      → 정점의 수 = V

      → 간선의 수 = V이하(MST까지) : 간선이 적다  VlogV : 적당한 간선  V^2:간선이 많다

**📊Kruskal**

- 간선을 기준으로 작은 가중치부터 고르자
    - 정렬이 사용됨
    - 간선이 E개 → 시간은 O(ElogE)
    - 사이클 검사(유니온파인드) → 거의 상수
    - 노드의 수 : 1000개
    
          → 완전 그래프
    
          → 모든 간선의 수 : 약 50만개
    
             ⇒ 시간 복잡도 : 50만log500,000
    
    - 결론 : 정점에 비해 간선이 적을수록 유리하다
    

**📊최단거리**

- Digkstra - 최단거리에서만
    - 최장거리는 풀 수 없음
- 벨만-포드로 접근

⬇️ 반례 ⬇️

더 긴 거리는 미리 확정 지을 수 없다 → 그리디로 접근하면 틀림

</aside>